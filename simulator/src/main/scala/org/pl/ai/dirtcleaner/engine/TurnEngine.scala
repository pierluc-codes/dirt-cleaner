/*
 * Copyright 2011 Pier-Luc Caron St-Pierre
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package org.pl.ai.dirtcleaner.engine

import com.weiglewilczek.slf4s.Logger
import org.pl.ai.dirtcleaner.agent.Cleaner
import org.pl.ai.dirtcleaner.agent.CleanerAction
import org.pl.ai.dirtcleaner.map.DirtyMap

/**
 * The turn engine is the class that perform the turn action during each turn of the simulation.
 * @author Pier-Luc Caron St-Pierre <pierluc.caronstpierre@gmail.com>
 *
 * @param cleaner The cleaner that will perform the turn
 * @param dirtyMap the map to execute the action.
 */
final class TurnEngine(val cleaner: Cleaner, val dirtyMap: DirtyMap) {

  val logger = Logger("Turn Engine")

  if (cleaner == null) {
    throw new IllegalArgumentException("Cleaner cannot be null")
  }

  if (dirtyMap == null) {
    throw new IllegalArgumentException("Dirty map cannot be null")
  }

  /**
   * Perform the next turn

   * @param currentX The position in x of the cleaner
   * @param currentY the position in y of the cleaner
   * @return A tuple containing the new position of the cleaner (x, y)
   */
  def playTurn(currentX: Int, currentY: Int) = {

    var cleanerAction = CleanerAction.Stand

    // Get the move, catch any exception generated by the agent
    try {
      cleanerAction = cleaner.getNextMove(dirtyMap.copyMap, currentX, currentY)

      if (cleanerAction == null) {
        logger.error(cleaner.getName + " returned null. The cleaner will stand")
      }
    } catch {
      case e => {
        logger.error(cleaner.getName + " move generated an exception. The cleaner will stand.", e)
      }
    }

    // Move the cleaner to the location
    var nextX = cleanerAction.getNextX(currentX)
    var nextY = cleanerAction.getNextY(currentY)

    if (!dirtyMap.getTile(nextX, nextY).canMove) {
      logger.warn(cleaner.getName + " try to move on a tile that is not a floor")
      nextX = currentX
      nextY = currentY
    }

    logger.debug(cleaner.getName + " is on case (" + nextX + ", " + nextY + ")")


    // Clean the tile
    if (cleanerAction == CleanerAction.Suck) {
      logger.debug(cleaner.getName + " agent suck the current tile")
      val cleanedTile = dirtyMap.getTile(nextX, nextY)
      cleanedTile.isDirty = false
      dirtyMap.setTile(nextX, nextY, cleanedTile)
    }

    (nextX, nextY)
  }

}